#------------------------------------------------------------------------------
#
#  WARNING !
#
#  This is a generated file. DO NOT EDIT THIS FILE! Your changes will
#  be lost the next time this file is regenerated.
#
#  This file was generated using asterisk-ari-client ruby gem.
#
#------------------------------------------------------------------------------

module Ari
  class Bridge < Resource

    attr_reader :id, :technology, :bridge_type, :bridge_class, :creator, :name, :channels, :video_mode, :video_source_id, :creationtime

    def creationtime=(val)
      @creationtime ||= Time.parse(val)
    end


    # GET /bridges
    #
    # Active bridges
    #
    #
    def self.list(options = {})
      path = '/bridges'
      response = client(options).get(path, options)
      response.map { |hash| Bridge.new(hash.merge(client: options[:client])) }
    end

    # POST /bridges
    #
    # Active bridges
    #
    #
    # Parameters:
    #
    # type  - Comma separated list of bridge type attributes (mixing, holding, dtmf_events, proxy_media, video_sfu, video_single).
    # bridgeId  - Unique ID to give to the bridge being created.
    # name  - Name to give to the bridge being created.
    #
    def self.create(options = {})
      path = '/bridges'
      response = client(options).post(path, options)
      Bridge.new(response.merge(client: options[:client]))
    end

    # POST /bridges/%{bridgeId}
    #
    # Individual bridge
    #
    #
    # Parameters:
    #
    # type  - Comma separated list of bridge type attributes (mixing, holding, dtmf_events, proxy_media, video_sfu, video_single) to set.
    # bridgeId (required) - Unique ID to give to the bridge being created.
    # name  - Set the name of the bridge.
    #
    def self.create_with_id(options = {})
      raise ArgumentError.new("Parameter bridgeId must be passed in options hash.") unless options[:bridgeId]
      path = '/bridges/%{bridgeId}' % options
      response = client(options).post(path, options)
      Bridge.new(response.merge(client: options[:client]))
    end
    class << self; alias_method :createWithId, :create_with_id; end

    def create_with_id(options = {})
      self.class.create_with_id(options.merge(bridgeId: self.id, client: @client))
    end

    # GET /bridges/%{bridgeId}
    #
    # Individual bridge
    #
    #
    # Parameters:
    #
    # bridgeId (required) - Bridge's id
    #
    def self.get(options = {})
      raise ArgumentError.new("Parameter bridgeId must be passed in options hash.") unless options[:bridgeId]
      path = '/bridges/%{bridgeId}' % options
      response = client(options).get(path, options)
      Bridge.new(response.merge(client: options[:client]))
    end

    def get(options = {})
      self.class.get(options.merge(bridgeId: self.id, client: @client))
    end

    # DELETE /bridges/%{bridgeId}
    #
    # Individual bridge
    #
    #
    # Parameters:
    #
    # bridgeId (required) - Bridge's id
    #
    def self.destroy(options = {})
      raise ArgumentError.new("Parameter bridgeId must be passed in options hash.") unless options[:bridgeId]
      path = '/bridges/%{bridgeId}' % options
      response = client(options).delete(path, options)
      return response
    rescue Ari::RequestError => e
      raise unless e.code == '404'
    end

    def destroy(options = {})
      self.class.destroy(options.merge(bridgeId: self.id, client: @client))
    end

    # POST /bridges/%{bridgeId}/addChannel
    #
    # Add a channel to a bridge
    #
    #
    # Parameters:
    #
    # bridgeId (required) - Bridge's id
    # channel (required) - Ids of channels to add to bridge
    # role  - Channel's role in the bridge
    # absorbDTMF  - Absorb DTMF coming from this channel, preventing it to pass through to the bridge
    # mute  - Mute audio from this channel, preventing it to pass through to the bridge
    # inhibitConnectedLineUpdates  - Do not present the identity of the newly connected channel to other bridge members
    #
    def self.add_channel(options = {})
      raise ArgumentError.new("Parameter bridgeId must be passed in options hash.") unless options[:bridgeId]
      raise ArgumentError.new("Parameter channel must be passed in options hash.") unless options[:channel]
      path = '/bridges/%{bridgeId}/addChannel' % options
      response = client(options).post(path, options)
      return response
    end
    class << self; alias_method :addChannel, :add_channel; end

    def add_channel(options = {})
      self.class.add_channel(options.merge(bridgeId: self.id, client: @client))
    end

    # POST /bridges/%{bridgeId}/removeChannel
    #
    # Remove a channel from a bridge
    #
    #
    # Parameters:
    #
    # bridgeId (required) - Bridge's id
    # channel (required) - Ids of channels to remove from bridge
    #
    def self.remove_channel(options = {})
      raise ArgumentError.new("Parameter bridgeId must be passed in options hash.") unless options[:bridgeId]
      raise ArgumentError.new("Parameter channel must be passed in options hash.") unless options[:channel]
      path = '/bridges/%{bridgeId}/removeChannel' % options
      response = client(options).post(path, options)
      return response
    end
    class << self; alias_method :removeChannel, :remove_channel; end

    def remove_channel(options = {})
      self.class.remove_channel(options.merge(bridgeId: self.id, client: @client))
    end

    # POST /bridges/%{bridgeId}/videoSource/%{channelId}
    #
    # Set a channel as the video source in a multi-party bridge
    #
    # Set a channel as the video source in a multi-party mixing bridge. This operation
    #
    # Parameters:
    #
    # bridgeId (required) - Bridge's id
    # channelId (required) - Channel's id
    #
    def self.set_video_source(options = {})
      raise ArgumentError.new("Parameter bridgeId must be passed in options hash.") unless options[:bridgeId]
      raise ArgumentError.new("Parameter channelId must be passed in options hash.") unless options[:channelId]
      path = '/bridges/%{bridgeId}/videoSource/%{channelId}' % options
      response = client(options).post(path, options)
      return response
    end
    class << self; alias_method :setVideoSource, :set_video_source; end

    def set_video_source(options = {})
      self.class.set_video_source(options.merge(bridgeId: self.id, client: @client))
    end

    # DELETE /bridges/%{bridgeId}/videoSource
    #
    # Removes any explicit video source
    #
    # Removes any explicit video source in a multi-party mixing bridge. This operation
    #  has no effect on bridges with two or fewer participants. When no explicit video
    #  source is set, talk detection will be used to determine the active video stream
    #
    # Parameters:
    #
    # bridgeId (required) - Bridge's id
    #
    def self.clear_video_source(options = {})
      raise ArgumentError.new("Parameter bridgeId must be passed in options hash.") unless options[:bridgeId]
      path = '/bridges/%{bridgeId}/videoSource' % options
      response = client(options).delete(path, options)
      return response
    rescue Ari::RequestError => e
      raise unless e.code == '404'
    end
    class << self; alias_method :clearVideoSource, :clear_video_source; end

    def clear_video_source(options = {})
      self.class.clear_video_source(options.merge(bridgeId: self.id, client: @client))
    end

    # POST /bridges/%{bridgeId}/moh
    #
    # Play music on hold to a bridge
    #
    #
    # Parameters:
    #
    # bridgeId (required) - Bridge's id
    # mohClass  - Channel's id
    #
    def self.start_moh(options = {})
      raise ArgumentError.new("Parameter bridgeId must be passed in options hash.") unless options[:bridgeId]
      path = '/bridges/%{bridgeId}/moh' % options
      response = client(options).post(path, options)
      return response
    end
    class << self; alias_method :startMoh, :start_moh; end

    def start_moh(options = {})
      self.class.start_moh(options.merge(bridgeId: self.id, client: @client))
    end

    # DELETE /bridges/%{bridgeId}/moh
    #
    # Play music on hold to a bridge
    #
    #
    # Parameters:
    #
    # bridgeId (required) - Bridge's id
    #
    def self.stop_moh(options = {})
      raise ArgumentError.new("Parameter bridgeId must be passed in options hash.") unless options[:bridgeId]
      path = '/bridges/%{bridgeId}/moh' % options
      response = client(options).delete(path, options)
      return response
    rescue Ari::RequestError => e
      raise unless e.code == '404'
    end
    class << self; alias_method :stopMoh, :stop_moh; end

    def stop_moh(options = {})
      self.class.stop_moh(options.merge(bridgeId: self.id, client: @client))
    end

    # POST /bridges/%{bridgeId}/play
    #
    # Play media to the participants of a bridge
    #
    #
    # Parameters:
    #
    # bridgeId (required) - Bridge's id
    # media (required) - Media URIs to play.
    # lang  - For sounds, selects language for sound.
    # offsetms  - Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.
    # skipms  - Number of milliseconds to skip for forward/reverse operations.
    # playbackId  - Playback Id.
    #
    def self.play(options = {})
      raise ArgumentError.new("Parameter bridgeId must be passed in options hash.") unless options[:bridgeId]
      raise ArgumentError.new("Parameter media must be passed in options hash.") unless options[:media]
      path = '/bridges/%{bridgeId}/play' % options
      response = client(options).post(path, options)
      Playback.new(response.merge(client: options[:client]))
    end

    def play(options = {})
      self.class.play(options.merge(bridgeId: self.id, client: @client))
    end

    # POST /bridges/%{bridgeId}/play/%{playbackId}
    #
    # Play media to a bridge
    #
    #
    # Parameters:
    #
    # bridgeId (required) - Bridge's id
    # playbackId (required) - Playback ID.
    # media (required) - Media URIs to play.
    # lang  - For sounds, selects language for sound.
    # offsetms  - Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified.
    # skipms  - Number of milliseconds to skip for forward/reverse operations.
    #
    def self.play_with_id(options = {})
      raise ArgumentError.new("Parameter bridgeId must be passed in options hash.") unless options[:bridgeId]
      raise ArgumentError.new("Parameter playbackId must be passed in options hash.") unless options[:playbackId]
      raise ArgumentError.new("Parameter media must be passed in options hash.") unless options[:media]
      path = '/bridges/%{bridgeId}/play/%{playbackId}' % options
      response = client(options).post(path, options)
      Playback.new(response.merge(client: options[:client]))
    end
    class << self; alias_method :playWithId, :play_with_id; end

    def play_with_id(options = {})
      self.class.play_with_id(options.merge(bridgeId: self.id, client: @client))
    end

    # POST /bridges/%{bridgeId}/record
    #
    # Record audio on a bridge
    #
    #
    # Parameters:
    #
    # bridgeId (required) - Bridge's id
    # name (required) - Recording's filename
    # format (required) - Format to encode audio in
    # maxDurationSeconds  - Maximum duration of the recording, in seconds. 0 for no limit.
    # maxSilenceSeconds  - Maximum duration of silence, in seconds. 0 for no limit.
    # ifExists  - Action to take if a recording with the same name already exists.
    # beep  - Play beep when recording begins
    # terminateOn  - DTMF input to terminate recording.
    #
    def self.record(options = {})
      raise ArgumentError.new("Parameter bridgeId must be passed in options hash.") unless options[:bridgeId]
      raise ArgumentError.new("Parameter name must be passed in options hash.") unless options[:name]
      raise ArgumentError.new("Parameter format must be passed in options hash.") unless options[:format]
      path = '/bridges/%{bridgeId}/record' % options
      response = client(options).post(path, options)
      LiveRecording.new(response.merge(client: options[:client]))
    end

    def record(options = {})
      self.class.record(options.merge(bridgeId: self.id, client: @client))
    end


  end
end

Ari::Client.send :define_method, 'bridges' do
  Ari::ListResource.new(self, Ari::Bridge)
end
